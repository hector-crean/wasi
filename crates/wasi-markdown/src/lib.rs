use std::cell::{RefCell, Cell};
use pulldown_cmark::{html, Options, Parser, Event, Tag, CodeBlockKind};
use syntect::highlighting::{ThemeSet};
use syntect::html::{highlighted_html_for_string, IncludeBackground};
use syntect::parsing::SyntaxSet;
use regex::Regex;

// This import will be generated by wit-bindgen
// It allows us to define how our Rust code maps to the WIT interface
wit_bindgen::generate!({
    path: "wit",
    world: "markdown",
});

use exports::wasi::markdown_parser::parser::Guest;

// Define a struct that will implement our exported WIT interface
struct MarkdownParser;

// Implement the `Guest` trait generated by `wit_bindgen::generate!`
// This trait corresponds to the `interface` defined in our WIT file.
impl Guest for MarkdownParser {
    fn parse_markdown(input: String) -> String {
        // By default, enable all enhanced features
        Self::parse_markdown_with_config(input, true, true)
    }
    
    fn parse_markdown_with_config(input: String, enable_syntax_highlighting: bool, enable_math: bool) -> String {
        // Configure markdown parsing options (e.g., enable tables, footnotes)
        let mut options = Options::empty();
        options.insert(Options::ENABLE_TABLES);
        options.insert(Options::ENABLE_FOOTNOTES);
        options.insert(Options::ENABLE_STRIKETHROUGH);
        options.insert(Options::ENABLE_TASKLISTS);
        options.insert(Options::ENABLE_SMART_PUNCTUATION);
        
        // Create a parser
        let parser = Parser::new_ext(&input, options);
        
        // Keep the original parser events
        let events: Vec<Event> = parser.collect();
        
        // Process the events if syntax highlighting is enabled
        let processed_events = if enable_syntax_highlighting {
            enhance_markdown_with_syntax_highlighting(events)
        } else {
            events
        };
        
        // Write to an HTML string
        let mut html_output = String::new();
        html::push_html(&mut html_output, processed_events.into_iter());
        
        // Apply additional post-processing
        if enable_math {
            html_output = process_math_formulas(html_output);
        }
        
        html_output
    }
}

/// Enhances the markdown parser with syntax highlighting for code blocks
fn enhance_markdown_with_syntax_highlighting(events: Vec<Event>) -> Vec<Event> {
    // Load syntax highlighting assets
    let syntax_set = SyntaxSet::load_defaults_newlines();
    let theme_set = ThemeSet::load_defaults();
    let theme = &theme_set.themes["base16-ocean.dark"];
    
    let mut processed_events = Vec::new();
    let mut in_code_block = false;
    let mut current_lang = String::new();
    let mut code_content = String::new();
    
    for event in events {
        match event {
            Event::Start(Tag::CodeBlock(CodeBlockKind::Fenced(lang))) => {
                in_code_block = true;
                current_lang = lang.to_string();
                // Add the start tag to output
                processed_events.push(Event::Start(Tag::CodeBlock(CodeBlockKind::Fenced(lang))));
            },
            Event::End(Tag::CodeBlock(CodeBlockKind::Fenced(_))) => {
                in_code_block = false;
                
                // If we have code content and a language, apply syntax highlighting
                if !code_content.is_empty()  {
                    // Try to highlight based on the language
                    if let Some(syntax) = syntax_set.find_syntax_by_token(&current_lang) {
                        // Apply syntax highlighting
                        match highlighted_html_for_string(&code_content, &syntax_set, syntax, theme) {
                            Ok(highlighted) => {
                                // Replace the plain code with highlighted HTML
                                // Note: in a real implementation, you would need to safely handle
                                // the highlighted HTML within the markdown parser
                                processed_events.push(Event::Text(highlighted.into()));
                            },
                            Err(_) => {
                                // Fall back to the original code if highlighting fails
                                processed_events.push(Event::Text(code_content.into()));
                            }
                        }
                    } else {
                        // Language not found, use the original text
                        processed_events.push(Event::Text(code_content.into()));
                    }
                } else {
                    // Empty code block or no language
                    processed_events.push(Event::Text(code_content.into()));
                }
                
                // Reset code content for next block
                code_content = String::new();
                current_lang = String::new();
                
                // Add the end tag to output
                processed_events.push(Event::End(Tag::CodeBlock(CodeBlockKind::Fenced("".into()))));
            },
            Event::Text(text) if in_code_block => {
                // Collect text within code block
                code_content.push_str(&text);
                // Don't add the text event yet, we'll add it with syntax highlighting
            },
            _ => {
                // Pass through all other events
                processed_events.push(event);
            }
        }
    }
    
    processed_events
}

/// Process math formulas in the HTML
fn process_math_formulas(html: String) -> String {
    // This is a simplified example. A real implementation would use a proper
    // math rendering library or prepare the HTML for MathJax/KaTeX
    
    // Example: identify inline math delimited by $ and add proper classes
    let inline_math_re = Regex::new(r"\$([^$]+)\$").unwrap();
    let html = inline_math_re.replace_all(&html, r#"<span class="math inline">\$\1\$</span>"#);
    
    // Example: identify block math delimited by $$ and add proper classes
    let block_math_re = Regex::new(r"\$\$([^$]+)\$\$").unwrap();
    let html = block_math_re.replace_all(&html, r#"<div class="math display">\$\$\1\$\$</div>"#);
    
    html.to_string()
}

export!(MarkdownParser);
